--- 
title: "Dialect Identification (dialectid)"
format: 
  dashboard:
    logo: images/ingeotec.png
    orientation: columns
    nav-buttons: [github]
    theme: cosmo
execute:
  freeze: auto    
---

```{python} 
#| echo: false 
#| include: false
#| label: setup

from collections import defaultdict, Counter
from os.path import join, basename, isfile
import pandas as pd
import numpy as np
from glob import glob
from IPython.display import Markdown
import seaborn as sns
from CompStats import metrics
from CompStats import measurements
from encexp.download import download
from encexp.utils import DialectID_URL
from microtc.utils import tweet_iterator
from microtc.utils import save_model, load_model
from dialectid import DialectId
sns.set_style('whitegrid')
sns.set_theme(font_scale=1.2)
ORDER = ['DialectId[19]', 'DialectId[18]', 'DialectId[17]',
         'DialectId[19] (prob)', 'DialectId[18] (prob)',
         'DialectId[17] (prob)',
         'DialectId[19] (262k)', 'DialectId[18] (262k)',
         'DialectId[17] (262k)', 'StackBoW (262k)']


def dataset_info(lang='es'):
    dataset = download('dialectid_dataset_info',
                       base_url=DialectID_URL)
    dataset = {data['set']: {k: v for k, v in data.items() 
                             if k not in ('lang', 'set')}
               for data in dataset if data['lang'] == lang}
    dataset = pd.DataFrame(dataset).reset_index(names='Country')
    return dataset.sort_values('Country')


def performance(lang, score, prefix='',
                value_name='macro-recall', **kwargs):
    fname = f'perf/{prefix}{lang}.gz'
    if isfile(fname):
        return load_model(fname)
    pred_dirname = f'dialectid-datasets/predictions/{lang}'
    for alg in ORDER:
        fname_pred = join(pred_dirname, f'{alg}.json')
        data = next(tweet_iterator(fname_pred))
        key = basename(fname_pred).split('.json')[0]
        if key == 'y':
            continue
        score(np.array(data), name=key)

    _ = score.dataframe(comparison=True,
                        value_name=value_name, **kwargs)
    _['Language'] = lang
    save_model(_, fname)
    return _


def country_recall(lang, col_wrap=5):
    detect = DialectId(lang=lang)
    pred_dirname = f'dialectid-datasets/predictions/{lang}'
    gold = next(tweet_iterator(join(pred_dirname, 'y.json')))
    score = metrics.recall_score(np.array(gold['y']), average=None)

    df = performance(lang, score, prefix='recall_', value_name='Recall',
                     var_name='Country',
                     perf_names=[f'{cntr}' for cntr in detect.countries])
    df.drop(columns=['Language'], inplace=True)
    ci = lambda x: measurements.CI(x, alpha=0.05)
    f_grid = sns.catplot(df, x='Recall', y='Algorithm', col_wrap=col_wrap,
                         capsize=0.2, linestyle='none', col='Country',
                         order=ORDER,
                         kind='point', errorbar=ci, # sharex=False,
                         hue='Comparison')
    return f_grid


def prior_proba(lang):
    freq = download('freq_countries_lang')
    data = freq[lang]['counter']
    del data['ALL']
    norm = sum(data.values())
    return {k: v / norm for k, v in data.items()}


def hprob_test(lang):
    fname = f'dialectid-datasets/predictions/dist-{lang}/DialectId[19].json.gz'
    _ = next(tweet_iterator(fname))
    data = Counter()
    data.update(_)
    norm = sum(data.values())
    return  {k: v / norm for k, v in data.items()}


def orig_dist_hprob_test(lang):
    fname = f'dialectid-datasets/predictions/dist-{lang}/DialectId[19] (Orig. Dist.).json.gz'
    if not isfile(fname):
        return None
    _ = next(tweet_iterator(fname))
    data = Counter()
    data.update(_)
    norm = sum(data.values())
    return  {k: v / norm for k, v in data.items()}  


def prior_test(lang):
    fname = f'dialectid-datasets/predictions/dist-{lang}/y.json.gz'
    _ = next(tweet_iterator(fname))
    data = Counter()
    data.update(_['y'])
    norm = sum(data.values())
    return  {k: v / norm for k, v in data.items()}


def dist_all(lang):
    if not isfile(f'pred-all/{lang}.json.gz'):
        return None
    data = Counter()
    data.update(next(tweet_iterator(f'pred-all/{lang}.json.gz')))
    norm = sum(data.values())
    return  {k: v / norm for k, v in data.items()}


def dist_all_origin_dist(lang):
    if not isfile(f'pred-all/{lang}.json.gz'):
        return None
    data = Counter()
    data.update(next(tweet_iterator(f'pred-all/{lang}-orig-dist.json.gz')))
    norm = sum(data.values())
    return  {k: v / norm for k, v in data.items()}


def dist_lang(lang):
    """Distribution"""

    test_values = hprob_test(lang)
    prior_train = sorted([(k, v) for k, v in prior_test(lang).items()
                          if k in test_values], key=lambda x: x[1])
    df = pd.DataFrame(prior_train, columns=['Country', 'Prob.'])
    df['Dataset'] = 'Test set'
    df['Target'] = 'Measured'
    for func, name, origin in zip([hprob_test,
                                   orig_dist_hprob_test, dist_all,
                                   dist_all_origin_dist],
                                  ['Test set', 'Test set',
                                   'w/o Geo. Inf.',
                                   'w/o Geo. Inf.'],
                                  ['DialectId',
                                   'DialectId (Orig. Dist.)',
                                   'DialectId', 'DialectId (Orig. Dist.)']):
        _info = func(lang)
        if _info is None:
            continue
        df2 = pd.DataFrame([(cntr, _info.get(cntr, 0), name)
                            for cntr, _ in prior_train],
                            columns=['Country', 'Prob.', 'Dataset'])
        df2['Target'] = origin
        df = pd.concat((df, df2))
    return sns.lineplot(df, x='Country', y='Prob.',
                        style='Target', hue='Target', size='Dataset')   
``` 

# Introduction

## Column 

::: {.card title='Introduction' .flow}  
`dialectid` aims to develop a set of algorithms to detect the dialect of a given text. For example, given a text written in Spanish, `dialectid` predicts the Spanish-speaking country where the text comes from. 

`dialectid` is available for Arabic (ar), German (de), English (en), Spanish (es), French (fr), Dutch (nl), Portuguese (pt), Russian (ru), Turkish (tr), and Chinese (zh).
:::

::: {.card title='Installing using conda' .flow}

`dialectid` can be install using the conda package manager with the following instruction.

```{sh} 
conda install --channel conda-forge dialectid
``` 
::: 

::: {.card title='Installing using pip' .flow} 
A more general approach to installing `dialectid` is through the use of the command pip, as illustrated in the following instruction.

```{sh} 
pip install dialectid
```
::: 

## Column

::: {.card title='Countries' .flow}
```{python}
#| echo: true
#| label: countries

from dialectid import DialectId
detect = DialectId(lang='es')
detect.countries
```
:::


# Quickstart

## Column 

::: {.card title='Dialect Identification' .flow}
```{python} 
#| echo: true
#| label: Identification

from dialectid import DialectId
detect = DialectId(lang='es')
detect.predict(['comiendo unos tacos',
                'acompañando el asado con un buen vino'])
```
:::

::: {.card title='Decision Function' .flow}
```{python} 
#| echo: true
#| label: Distance

from dialectid import DialectId
detect = DialectId(lang='es')
df = detect.decision_function(['acompañando el asado con un buen vino'])[0]
index = df.argsort()[::-1]
[(detect.countries[i], df[i]) for i in index
 if df[i] > 0]
```
:::

## Column 

::: {.card title='Probability' .flow}
```{python} 
#| echo: true
#| label: Probability

from dialectid import DialectId
detect = DialectId(lang='es', probability=True)
prob = detect.predict_proba(['acompañando el asado con un buen vino'])[0]
index = prob.argsort()[::-1]
[(detect.countries[i], prob[i])
 for i in index[:4]]
```
:::

# Corpora 

## Column {.tabset} 


::: {.card title='Arabic (ar)'}
```{python}
#| echo: false
#| label: tbl-arabic
#| tbl-cap: Number of tweets in the training and test sets for the Arabic-speaking countries. 

Markdown(dataset_info('ar').to_markdown(index=False))
```
:::

::: {.card title='German (de)'}
```{python}
#| echo: false
#| label: tbl-german
#| tbl-cap: Number of tweets in the training and test sets for the German-speaking countries.

Markdown(dataset_info('de').to_markdown(index=False))
```
:::

::: {.card title='English (en)'}
```{python}
#| echo: false
#| label: tbl-english
#| tbl-cap: Number of tweets in the training and test sets for the English-speaking countries.

Markdown(dataset_info('en').to_markdown(index=False))
```
:::

::: {.card title='Spanish (es)'}
```{python}
#| echo: false
#| label: tbl-spanish
#| tbl-cap: Number of tweets in the training and test sets for the Spanish-speaking countries.

Markdown(dataset_info('es').to_markdown(index=False))
```
:::

::: {.card title='French (fr)'}
```{python}
#| echo: false
#| label: tbl-french
#| tbl-cap: Number of tweets in the training and test sets for the French-speaking countries.

Markdown(dataset_info('fr').to_markdown(index=False))
```
:::

::: {.card title='Dutch (nl)'}
```{python}
#| echo: false
#| label: tbl-dutch
#| tbl-cap: Number of tweets in the training and test sets for the Dutch-speaking countries.

Markdown(dataset_info('nl').to_markdown(index=False))
```
:::

::: {.card title='Portuguese (pt)'}
```{python}
#| echo: false
#| label: tbl-portuguese
#| tbl-cap: Number of tweets in the training and test sets for the Portuguese-speaking countries.

Markdown(dataset_info('pt').to_markdown(index=False))
```
:::

::: {.card title='Russian (ru)'}
```{python}
#| echo: false
#| label: tbl-russian
#| tbl-cap: Number of tweets in the training and test sets for the Russian-speaking countries.

Markdown(dataset_info('ru').to_markdown(index=False))
```
:::

::: {.card title='Turkish (tr)'}
```{python}
#| echo: false
#| label: tbl-turkish
#| tbl-cap: Number of tweets in the training and test sets for the Turkish-speaking countries.

Markdown(dataset_info('tr').to_markdown(index=False))
```
:::

::: {.card title='Chinese (zh)'}
```{python}
#| echo: false
#| label: tbl-chinese
#| tbl-cap: Number of tweets in the training and test sets for the Chinese-speaking countries.

Markdown(dataset_info('zh').to_markdown(index=False))
```
:::

## Column 

::: {.card title="Description"}
The dataset used to create the self-supervised problems is a collection of Tweets collected from the open stream for several years, i.e., the Spanish collection started on December 11, 2015; English on July 1, 2016; Arabic on January 25, 2017; Russian on October 16, 2018; and the rest of the languages on June 1, 2021. In all the cases, the last day collected was June 9, 2023. The collected Tweets were filtered with the following restrictions: retweets were removed; URLs and usernames were replaced by the tokens _url and _usr, respectively; and only tweets with at least 50 characters were included in the final collection. 

The corpora are divided into two sets: the first set is used as a training set, i.e., to estimate the parameters, while the second set corresponds to the test set, which could be used to measure the model's performance. The basis for this division is a specific date, with tweets published before October 1, 2022, forming the first set. Those published on or after October 3, 2022, are being used to create the test set. 

The procedure has two stages. Two datasets were created for each country and language in the first stage. The first one contains $2^{23}$ (8 million) tweets, and the second has $2^{12}$ (4,096) tweets; the former will be used to create the training set, and the latter corresponds to the test set. These two sets were constructed using tweets with geographic information and filtered according to the language information provided by Twitter. Each set was meticulously crafted to follow, as closely as possible, a uniform distribution of the days. Within each day, near duplicates were removed. Then, a three-day sliding window was used to remove near duplicates within the window. The final step was to shuffle the data to remove the ordering by date. 

In the second stage, training sets are created for each language. Each training set contains $2^{21}$ (2 million) tweets. The procedure used to develop the training consists of drawing tweets from the sets created in the first stage, which have a size of $2^{12}$. The sampling procedure aims to develop training sets that follow a uniform distribution by country. We also produce a smaller training set containing $2^{18}$ (262 thousand) tweets. The procedure is equivalent to the previous one; the aim is to have a uniform distribution of the countries. 

It is worth mentioning that we did not have enough information for all the countries and languages to follow an exactly uniform distribution. For example, it can be observed in @tbl-spanish (Spanish) that for Puerto Rico (pr), there are only 12,407 tweets in the training set and 1,487 tweets in the test set, which correspond to the total number of available tweets that met the imposed restrictions.
:::

# Performance

## Column {.tabset}

::: {.card title='Macro-recall'}
```{python}
#| echo: false
#| fig-cap: Performance of the different algorithms and languages. 
#| label: fig-macro-recall

df = pd.DataFrame()
for lang in ['es', 'en', 'ar',
             'de', 'fr', 'nl',
             'pt', 'ru', 'tr',
             'zh']:
    pred_dirname = f'dialectid-datasets/predictions/{lang}'
    gold = next(tweet_iterator(join(pred_dirname, 'y.json')))
    if 'score' in gold:
        score = gold['score']
    else:
        score = 'macro_recall'
    score = getattr(metrics, score)(np.array(gold['y']))
    _ = performance(lang, score)
    df = pd.concat((df, _))
ci = lambda x: measurements.CI(x, alpha=0.05)
f_grid = sns.catplot(df, x='macro-recall', y='Algorithm', col_wrap=3,
                     capsize=0.2, linestyle='none', col='Language',
                     order=ORDER,
                     kind='point', errorbar=ci, sharex=False,
                     hue='Comparison')
```
:::

::: {.card title='Arabic (recall)'}

```{python}
#| echo: false
#| label: Arabic-perf

country_recall('ar')
```
::: 

::: {.card title='German (recall)'}
```{python}
#| echo: false
#| label: German-perf

country_recall('de', col_wrap=None)
```
::: 

::: {.card title='English (recall)'}
```{python}
#| echo: false
#| label: English-perf

country_recall('en', col_wrap=7)
```
::: 

::: {.card title='Spanish (recall)'}
```{python}
#| echo: false
#| label: Spanish-perf

country_recall('es')
```
::: 

::: {.card title='French (recall)'}
```{python}
#| echo: false
#| label: French-perf

country_recall('fr')
```
::: 

::: {.card title='Dutch (recall)'}
```{python}
#| echo: false
#| label: Dutch-perf

country_recall('nl', col_wrap=None)
```
::: 

::: {.card title='Portuguese (recall)'}
```{python}
#| echo: false
#| label: Portuguese-perf

country_recall('pt', col_wrap=3)
```
::: 

::: {.card title='Russian (recall)'}
```{python}
#| echo: false
#| label: Russian-perf

country_recall('ru', col_wrap=2)
```
::: 

::: {.card title='Turkish (recall)'}
```{python}
#| echo: false
#| label: Turkish-perf

country_recall('tr', col_wrap=None)
```
::: 

::: {.card title='Chinese (recall)'}
```{python}
#| echo: false
#| label: Chinese-perf

country_recall('zh', col_wrap=2)
```
::: 


## Column 

::: {.card title='Performance'}

The performance of different algorithms is presented in @fig-macro-recall using macro-recall. The best-performing system in almost all cases is DialectId, which is trained on 2 million tweets and has a vocabulary of 500,000 tokens. The exception are Turkish and Dutch, where the best systems is StackBoW trained with only 262k tweets.

The remaining figures provide details on macro-recall by presenting the system's recall in each country. 
::: 


# Distribution 

## Column {.tabset}

::: {.card title='Arabic'}
```{python}
#| echo: false
#| label: Arabic-dist

dist_lang('ar')
```
:::

::: {.card title='German'}
```{python}
#| echo: false
#| label: German-dist

dist_lang('de')
```
:::

::: {.card title='English'}
```{python}
#| echo: false
#| label: English-dist

dist_lang('en')
```
:::

::: {.card title='Spanish'}
```{python}
#| echo: false
#| label: Spanish-dist

dist_lang('es')
```
:::

::: {.card title='French'}
```{python}
#| echo: false
#| label: French-dist

dist_lang('fr')
```
:::

::: {.card title='Dutch'}
```{python}
#| echo: false
#| label: Dutch-dist

dist_lang('nl')
```
:::

::: {.card title='Portuguese'}
```{python}
#| echo: false
#| label: Portuguese-dist

dist_lang('pt')
```
:::

::: {.card title='Russian'}
```{python}
#| echo: false
#| label: Russian-dist

dist_lang('ru')
```
:::

::: {.card title='Turkish'}
```{python}
#| echo: false
#| label: Turkish-dist

dist_lang('tr')
```
:::

::: {.card title='Chinese'}
```{python}
#| echo: false
#| label: Chinese-dist

dist_lang('zh')
```
:::

## Column 

::: {.card title='Description'}

XxX

::: 